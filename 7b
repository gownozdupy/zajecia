#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

// Struktura reprezentująca punkt w n-wymiarowej przestrzeni
struct Punkt {
    std::vector<double> wspolrzedne;

    // Konstruktor, który inicjalizuje punkt o zadanej liczbie współrzędnych
    explicit Punkt(size_t wymiary) : wspolrzedne(wymiary) {}
};

// Generator liczb losowych o rozkładzie normalnym N(5,10)
class GeneratorRozkladuNormalnego {
private:
    std::default_random_engine generator;
    std::normal_distribution<double> rozklad;

public:
    GeneratorRozkladuNormalnego(double srednia, double odchylenie_standardowe) : rozklad(srednia, odchylenie_standardowe) {}

    double operator()() {
        return rozklad(generator);
    }
};

int main() {
    // Krok 1: Generowanie chmury punktów A
    size_t wymiary;
    std::cout << "Podaj wymiar przestrzeni n: ";
    std::cin >> wymiary;

    std::vector<Punkt> chmuraA(100, Punkt(wymiary));
    GeneratorRozkladuNormalnego generator(5.0, 10.0);

    std::generate(chmuraA.begin(), chmuraA.end(), [&generator, wymiary](Punkt &punkt) {
        std::generate(punkt.wspolrzedne.begin(), punkt.wspolrzedne.end(), generator);
        return punkt;
    });

    // Krok 2: Obliczenie centroidu chmury A
    Punkt centroidA(wymiary);
    auto suma = std::accumulate(chmuraA.begin(), chmuraA.end(), Punkt(wymiary),
                                [](const Punkt &p1, const Punkt &p2) {
                                    Punkt wynik(p1);
                                    std::transform(wynik.wspolrzedne.begin(), wynik.wspolrzedne.end(),
                                                   p2.wspolrzedne.begin(), wynik.wspolrzedne.begin(),
                                                   std::plus<double>());
                                    return wynik;
                                });

    std::for_each(centroidA.wspolrzedne.begin(), centroidA.wspolrzedne.end(),
                  [rozmiar = chmuraA.size()](double &wsp) { wsp /= rozmiar; });

    // Krok 3: Wypisanie współrzędnych centroidu A
    std::cout << "Centroid chmury A: ";
    std::copy(centroidA.wspolrzedne.begin(), centroidA.wspolrzedne.end(), std::ostream_iterator<double>(std::cout, " "));
    std::cout << std::endl;

    // Krok 4: Generowanie chmury punktów A' symetrycznej do A względem centroidu
    std::vector<Punkt> chmuraAprime(chmuraA.size(), Punkt(wymiary));
    std::transform(chmuraA.begin(), chmuraA.end(), chmuraAprime.begin(),
                   [&centroidA](const Punkt &punkt) {
                       Punkt wynik(wymiary);
                       std::transform(punkt.wspolrzedne.begin(), punkt.wspolrzedne.end(),
                                      centroidA.wspolrzedne.begin(), wynik.wspolrzedne.begin(),
                                      [](double wsp, double centroidWsp) {
                                          return 2 * centroidWsp - wsp;
                                      });
                       return wynik;
                   });

    // Krok 5: Obliczenie centroidu chmury A'
    Punkt centroidAprime(wymiary);
    suma = std::accumulate(chmuraAprime.begin(), chmuraAprime.end(), Punkt(wymiary),
                           [](const Punkt &p1, const Punkt &p2) {
                               Punkt wynik(p1);
                               std::transform(wynik.wspolrzedne.begin(), wynik.wspolrzedne.end(),
                                              p2.wspolrzedne.begin(), wynik.wspolrzedne.begin(),
                                              std::plus<double>());
                               return wynik;
                           });

    std::for_each(centroidAprime.wspolrzedne.begin(), centroidAprime.wspolrzedne.end(),
                  [rozmiar = chmuraAprime.size()](double &wsp) { wsp /= rozmiar; });

    // Porównanie centroidów
    std::cout << "Centroid chmury A': ";
    std::copy(centroidAprime.wspolrzedne.begin(), centroidAprime.wspolrzedne.end(),
              std::ostream_iterator<double>(std::cout, " "));
    std::cout << std::endl;

    if (centroidA.wspolrzedne == centroidAprime.wspolrzedne) {
        std::cout << "Centroidy chmur A i A' są identyczne." << std::endl;
    } else {
        std::cout << "Centroidy chmur A i A' są różne." << std::endl;
    }

    return 0;
}
